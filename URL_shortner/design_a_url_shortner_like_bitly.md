# Design a URL shortener like bit.ly

# Sincerest Credits: 
- Naren - https://www.youtube.com/watch?v=JQDHz72OA3c
- Tushar Roy - https://www.youtube.com/watch?v=fMZMm_0ZhK4 (15:17)

## Introduction
All-in-all, this appears to have an 

1.  **App service:** Contains an API/code that will convert a URL to its shortened version and whenever the shortened URL is used, it converts it into its original form by looking up the key-value data

2. Key-Value Database: A key-value database that will save the shortened version of the URL. Key will be the shortened version of the URL and value will be its original version

However, the scale, the traffic everything is important.

## Few questions that could be asked

1. What is the length of the URL to be shortened?
2. What would be the traffic?
3. Should a single service be used or should we scale it? This would depend on the traffic

## Assumptions

Some assumptions about the traffic/users
1. Twitter has 300 million users/month. Assume we get 10% of that, that is 30 million users per month.
2. Lets keep the length of shortened URL to 7 characters.
3. After creation, the shortenend version of the URL will expire after 72 hours.

## Data capacity model

### Fields
We will have the following fields stored for a single URL

1. Long URL: 2 KB (2048 chars)
2. short URL: 17 bytes (17 chars. http://www.ly.com/_______  7 shortenend chars + 10 chars of website name) 
3. created_at: Epoch Timestamp 7 Bytes
4. expired at: Epoch Timestamp: 7 Bytes.

---------------------------------------
Total: 2.031 KB

### Storage required for 1 month, 1 year and 5 years
Let's assume that 30 M users each have a single URL saved in a single day. So the storage capacity would be

30 M users ---> 

    - 60.031 GBs per month
    - 0.7 TBs per year
    - 3.5 TBs per 5 years

The choice of whether to use an RDBMS/NoSQL depends on data access patterns.

## Core logic to generate a shortened URL

We have to generate a 7 char random ID for each URL viz. http://www.ly.com/XXXXXXX, where XXXXXXX is the unique ID. We have below choices of algorithms to be used here.

1. MD5: 
    - Give the long URL as input to MD5 generator.  Take a 7-character substring of the hash as the shortened version of the URL. 
    - MD5 may lead to collisions wherein two different long URLs have the same hash. The theoratical probablity of collision is if you generate 6 billion hashes per second, a collision can happen in 100 years. However, now its artificially possible to generate MD5 collisions (https://www.avira.com/en/blog/md5-the-broken-algorithm#:~:text=MD5%3A%20The%20fastest%20and%20shortest,%3A%201.47*10%2D29.&text=SHA256%3A%20The%20slowest%2C%20usually%2060,generated%20hash%20(32%20bytes). All we need is time, hardware and proper software.
    - Even if we don't get the entire hash collision, the first 7 characters of any generated hash can be same.

2. Base62: Base62 uses 62 characters (A-Z, a-z and 0-9). We get 62^7 ~ 3.5 trillion different combinations. If we generate 1000 URLs per second, the system will last to 110 years. If it generates 1 million URLs per second, this will last for 40 days. To generate more number of URLs per second, we need to increase the number of characters in the short URL. A number between 0 to 3.5 trillion can be represented in 43 bits

3. Base10: Base10 uses just 10 characters. we get just 10^7 ~ 10 million different combinations

We choose Base62 hashing scheme on the basis of the above arguments.

```
So 7-Character short URL Code = Substring(Base62(Random ID), 0, 7)
```

## Choice of database

1. RDBMS is pretty hard to scale. Sharding can be implemented but its complex when we want to horizontally scale.

2. NoSQL can be used for scaling: Eventual consistency, highly available and easy to scale - keep adding nodes.

### How to generate the tiny URL
#### Technique 1 Directly insert
1. We cannot simply generate a random ID, gets its base62 hash and use it as a short URL. 

2. We also need to check if that base62 hash of that random number has already been used. If that has been used, we have to generate a new random number.

3. This system works if we have a single app server. For multiple app servers, there can be a case where a single random number is generated by any two app server for different long URLs. This leads to two different long URLs referring to the same short URL
             
             Long URL            Short URL   
             
              A                   XXX

              B                   XXX

4. If the database supports putIfAbsent method, we can even use it to insert the short URL if it already does not exist. For relational databases, this is a trivial operation. 

5. We can do below operations infinitely till we can successfully generate a short URL without collisions
    - PUT a generated short_url from a long_url
    - GET the long_url by providing the short_url
    - Compare it with the original long_url. If it does not equal, redo the process.

#### Technique 2 Use MD5 to generate the long URL's hash
1. MD5 gives a fixed hash for a given hash 
2. We can take the first 7 characters of the generated hash (first 43 bits) of the long URL. How does first 43 bits of an MD5 map to 7 characters? 
    - Convert first 43 bits into binary
    - Convert it into a decimal
    - Repeatedly divide and mod that decimal by 62 to convert into base62
    - This will give whole numbers between 0 t0 61. 
    - Map those numbers to characters 
3. Possibility of collisions either the full hash code or the first 7 characters.
4. Probablity of collision is inversely proportional to the number of characters.


#### Techique 3 Use counters
1. Single Host: We can use incremental counters to generate the base62 hash code instead of statistically random number which may repeat. This can work only if the service is a single instance.

2. Counter Service: We can have a counter service to supply the counter values. We can use it to generate unique code as

7 character unique code = `Base62(6-bit random number + 32 bit epoch timestamp + 4 Bit substring of Mac address )`

But it too has problems

    - It becomes a single point of failure.
    - Even if we add multiple instances of the service, one or two per region we would need to give each one a range of counter values for example: 1 to 5 million, 5 million and 1 to 10 million and so on.
    - Counter values can get exhausted because of 32-bit integer limit on platforms.

3. We can use a distributed coordination service - Zookeeper to coordinate amongst the different instances of Counter services.
    - Zookeeper keeps configuration of each node.
    - It knows which are the active services and which services are down,
    - It assigns a unique ID to each service.

4. We can even use UUIDv4 to avoid inctroducing Zookeeper into the system - a third component that's not necessary.

## Actual System Design (Using Counters Way)
### Components
1. Load balancers to load balance incoming requests among multiple app servers
2. 3 or more App servers that contain actual business logic to transform a short URL to a long URL and vice-verse.
3. Cache (Redis/Memcached) that stores mapping between a long URL or short URL
4. Zookeeper cluster (assuming that we will go the counters way to generate a unique ID)
5. NoSQL DB for storing the URL data. Set the replicator factor and consistency level (e.g 3) appropriately to ensure that a quorum of nodes always gives the correct results.
    - We can use an RDBMS here as well. Since we have a fixed structure of records.
    - We can use MySQL with  a database clustering system like Vitess.

### Interaction between the App server and Zookeeper
1. When each instance of the service comes up, it registers itself with Zookeeper. 
2. Zookeeper provides each service with an ID. 
3. The Zookeeper cluster is preconfigured with a range of Unique ID values to be alloted to each instance of service.

       S1       1 Lac to 5 Lac
       S3       5,00,001 to 10 Lacs
       S4       10,00,0001 to 15 Lacs
                15,00,0001 to 20 Laks
                20,00,0001 to 25,00,000 Lacs

    
    The remaining ranges are un-used.
4. So each instance can generate unique IDs only within the alloted range. If the ranges get used, the next unused range is alloted to the server.
5. In this way there won't be any collisions and you also don't need to check for the presence of unique ID for a different URL to be already present in the DB.

### System design architecture diagram

![URL Shortner](https://raw.githubusercontent.com/verisimilitude20201/system-design/main/URL_shortner/bitly1.png)

## REST APIs

1. PUT /url/short
      {
          "long_url": "<LONG_URL>"
      }

    201 CREATED --> CREATED. 
    400 --> Invalid Long URL

    Response:
    {
        "long_url": "<LONG_URL>",
        "short_url": "http://ly.com/XXXXXXX"
        "created_at": "<EPOCH_TIMESTAMP>",
        "expired_at": "<EPOCH_TIMESTAMP>"
    }

2. GET /url/long/{short_url}